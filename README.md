# RecastNavigation学习和注释
## SoloMesh方案
### 第一步 初始化配置
主要设置构建的区域，指定输入网格的边界等
### 第二步 光栅化输入的多边形
首先要标记可行走的三角形，计算方法是构造三角形的法线并归一化，然后和可行走的最大角度比较即可
可达的三角形被标记为`RC_WALKABLE_AREA`
然后正式进行光栅化。首先遍历所有三角形，对每个三角形单独处理。
对每个三角形进行切割，切割的具体思路是，看该图形的每条边的两个端点在切割轴的左边还是右边，如果异侧则产生切割，切割产生的新分离点是该边和分离轴的交点，根据比例即可得出。
首先在z轴上切割，切出长条，然后再在x轴上切割，得到小块的体素。然后计算在该小格在y轴上的范围。
最后需要把体素捕捉到高度场。高度场的结构是二维数组(x轴z轴)，每个节点是一个链表(y轴)在y轴中会按从低到高顺序保存体素。如果新插入的体素和之前的体素有重合，则会合并，所以最终会得到在y轴上连续合并后的体素结构。
至此完成初步体素化
### 第三步 过滤可行走表面
主要是根据高度场对可行走面进行修正一共三种情况，不可走的标记为`RC_NULL_AREA`

1. 过滤悬空的可行障碍物

这种情况通俗来说就是，如果一个障碍物悬空，但可以爬上去，则该障碍物也是可走的

2. 过滤高度差过大的障碍物

这种情况可以理解为，如果过于陡峭，则不能通过。
这里的高度都是指上表面高度
首先要判断可达邻居，条件为与当前体素的高度差能通过一个人。
高度差过大的判断条件：可达邻居的最大高度和最低高度差大于攀爬高度或该体素与可达邻居的最低高度差大于攀爬高度，都认为过于陡峭，不可达。

3. 过滤不可通过高度的障碍物

即两个y轴上的体素之间的空隙不能过一个人，则下面的体素设置为不可行走。
至此完成体素化部分的优化，下面开始进入反体素化
### 第四步 区域划分
首先要构建紧缩高度场，紧缩高度场保存的是体素之间的可行部分，即空隙部分。构建紧缩高度场的环节就是反体素化。
紧缩高度场的数据结构和高度场也有不同，紧缩高度场的y轴也是通过连续内存即数组的形式保存，所以需要保存反体素的总数。
构建紧缩高度场后还需要构建反体素之间的联通关系，联通的条件有两个：最小间距大于人，下表面高度差小于攀爬高度。
然后需要根据角色半径对可行表面进行裁剪：即边缘部分虽然理论可走，但角色有半径，不可能走到最边缘。步骤如下

- 首先将边界标记出来：边界的条件是：本身不可走或者四个方向存在不联通的方向。
- 计算每个反体素与边界的最近距离。遍历即可，需要正反遍历两遍来处理周围八个点(因为先后顺序问题)
- 如果与边界距离小于角色直径，视为不可走，标记为`RC_NULL_AREA`

裁剪后有一个可选环节，根据部署的多边形，对反体素的area进行标记(即游戏中的草地，沙漠等等)
然后正式开始区域划分，主要介绍分水岭算法

1. 该算法的第一步是构建距离场，所谓距离场和上文根据角色半径裁剪用的距离计算数组基本一致，区别是边界的条件不同，这里的边界不仅包含四个方向存在不联通或本身不可走，如果四个方向存在area不同(比如草地和沙漠)也视为边界。这里会保留最大距离，后面区域划分会用到。
2. 平滑处理，将得到的距离场和周围八个点取平均值(如果有不联通，用自己进行占位)
3. 一开始给边界(整个包围盒)的regionID加上`RC_BORDER_REG`，然后根据上述平滑处理后的距离场开始进行区域划分。首先，区域划分是分批次的，每次8个等级，循环进行。每个等级保存2格距离。根据最大距离向下逐个等级进行划分。具体的区域划分有两个环节，一个环节是水位蔓延，根据当前等级进行蔓延，如果同等级没有被蔓延，会在第二阶段：发现新水源阶段成为新的水源。每个新的水源代表一个新的区域。需要注意region的边界id为0
4. 划分好之后需要对regions进行合并和过滤。首先遍历所有反体素，统计每个regionID中的反体素数量，并在每个反体素的竖直方向上regionID比较，如果相同，说明对应的regionID存在重叠情况，标记。并且会把该数值方向上的全部region去重添加到各个region的floors中。然后判断一个反体素是否是边缘，判断条件:与邻居span不联通或者不是同一个regionID。如果是边缘，则进行一次边缘行走，得到所有的邻居(可以联通的)region
   边缘行走的基本规则：**碰壁则向顺时针尝试，成功则前进一步并逆时针尝试**，这样最终能得到顺时针顺序的轮廓点排序。在行走的过程中会计算当前节点的高度，在这个过程中，会将边缘顶点标记为`RC_BORDER_VERTEX`
   基于刚刚计算的反体素数量统计，如果有region的反体素数量过少，则遍历该region的邻居，使用宽搜进行统计，看如果全部合并是否能保证反体素数量是合适的。如果不满足条件，这次宽搜到的所有region都可以直接杀掉。然后进行region的合并。将过小的region合并到邻居region。合并邻居的选择条件：不能有多个联通(这样中间会包夹别的region)，不能处于上下floor，在此基础上，选择最小的邻居进行合并。合并后，重新编号以压缩区域数组
### 第五步 轮廓化
到上一步为止，我们已经拿到了反体素并完成了区域划分，即每个反体素属于哪个区域。接下来我们将立体的反体素简化为轮廓。
首先，标记每个反体素四个方向是否为边界(regionID为0或者`RC_BORDER_REG`)
然后筛选出有部分方向为边界的反体素，进行轮廓点描绘，基本思路是绕着边界走一圈，将边界加入points数组。基本方法和上面的边缘行走差不多，有一个关键点是边缘的选取，要保证相邻的两个region共用一个边缘，所以要有一套规则：
```cpp
// 选取轮廓(为了保证周围的区域选出来的轮廓重合)
switch(dir)
{
    // 向左：取上
    case 0: pz++; break;
    // 向上：取右上
    case 1: px++; pz++; break;
    // 向右：取右
    case 2: px++; break;
    // 向下：取自身
}
```
在轮廓点中还会保存接壤点的情况，用于下面的简化轮廓线。
画出轮廓线之后，目前的轮廓点过于密集，其实只需要取其中一些关键点，构成多边形即可，这样即能优化性能，还可以减少锯齿。
首先对比本点和下一个轮廓点，如果两个轮廓点的接壤点不同，则把本点加入简化序列，如果没有这样的点，取左下和右上。然后：

1. 找出距离简化点围成的线段最远的点，如果不符合规定，就把该点加入。
2. 找出最长的线段，不符合规定，把中点加入

重复直到合格。
这时候已经得到了轮廓线，但内部会有回字形结构，需要去除这些回字形的空洞。
之前我们采用顺时针的方式进行边界遍历，那么内部的回字形就会是逆时针的(因为其实是从外部跑出来的)所以对面积进行叉乘，根据正负就能判断是外轮廓还是里面的空洞。
然后就要进行空洞合并或者说打通，即连接外轮廓和内轮廓，这样就可以保持只有一个轮廓。
合并的第一步是选点，找到内轮廓最左的点，并确保在外轮廓三个顶点围成的锥形区域内。然后用外轮廓的顶点对内轮廓的选定点进行连线，如果不和外轮廓即其他空洞相交，视为合法对角线，找到最短的合法对角线，如果没有合法对角线，内轮廓选择下一个最佳点。
### 第六步 构建PolyMesh
上一步当中已经得到了很多多边形结构，这一步主要是为了解决有的多边形是凹多边形这种不符合要求的情况。
首先第一步，使用耳裁法进行三角剖分，逐个选择耳根距离最近的耳尖切割成三角形，最终得到三角形数组。
然后将轮廓上的点添加到网格并将垂直高度在2以内(x、z相同)的点合并。
利用刚刚得到的三角形数组构建多边形，优先选择共边最长的两个凸多边形，并且确保两共点在合并后仍然能维持凸点，这样的多边形合并才是合法的。合并在网格中存储多边形信息，每个多边形由2*最大顶点数的数组表示，前半数组是多边形的顶点，后半数组用于构建多边形间的邻接关系，即保存邻接点，这个后面还会再说到。
合并好多边形之后要删除边界顶点，核心步骤是判断是否可删除和具体的删除操作。
一个节点是不可删除的只要具备以下条件之一

1. 删除该点之后剩下的点不足以构成多边形，比如一个单独的三角形(没有边和别的图形邻接)。
2. 有三条以上的边是没有被复用的(比如两个三角形不邻接，但共享一个顶点)

删除节点的流程如下

1. 记录不包含删除节点的边数组
2. 删除包含要删除节点的多边形(可能是多个)
3. 在网格中删除节点
4. 调整记录的边的序号，去掉删除节点的序号，这时，边数组可以再次联通，利用边数组生成多边形，主要方法是先记录第一个点，然后在两侧不断加入点(利用边数组)直到成为闭环
5. 此时多边形发生变化，所以需要从头走一下，首先是耳裁法三角剖分，然后构建多边形。

至此得到了多边形网格，但此时的多边形网格没有关注y轴的情况，是平铺的，如果有小土坡等等就会发现网格在地形的下方。
### 第七步 构建高度细节网格
这一步主要是对高度进行采样，让网格在y轴上也贴近地形。
对于每个多边形，根据regionID从紧缩高度场中遍历并取出高度信息。这一步的主要思路是，首先找到一个体素(即反体素，后面都叫体素了，因为大多数资料都是这么写的，也不会太有歧义)和多边形的regionID一致，通过这个体素进行宽搜扩展，给多边形涉及到的每个单位格标记高度。
有了高度信息后主要是进行简化，简化的基本思路是采样，类似前面对轮廓点的简化。
在采样前会计算多边形的最小伸展，即多边形上顶点到其他边的最大距离的最小值。最小伸展反映了多边形的方正度，后面会用到。
首先是根据多边形的边进行采样，首先根据采样数和多边形的边的端点坐标以及前面算出来的高度数据计算出每个采样点。这样会拿到极限数量的采样点，然后开始简化。首先把两个端点的采样点启用，然后找到距离当前简化点组成的边最远的采样点，计算距离，如果距离超过误差，则把该点加入，循环到不超过误差。
然后进行三角剖分，这里的三角剖分和上面的裁耳法并不相同。刚刚得到的采样点数组中相邻三个点可以组成三角形，找到周长最小的三角形作为起始。去掉耳尖和整个三角形，比较以耳根为边的两个三角形的周长，去掉小的那个，不断循环。
三角剖分之后，如果多边形的方正度并不好，就到这里结束了，如果比较方正，还可以根据多边形的面进行采样。
首先是在面上根据采样距离进行采样（每sampleDist取一个点）
然后循环执行下面操作

1. 找到采样点中真实距离和三角形网格最远，即误差最大的点，基本计算思路是遍历所有的三角形，找到最小距离就是采样点和三角形网格的距离。
2. 如果这个点不符合误差范围，就要加入网格。
3. 加入网格后，进行一次**delaunay三角剖分**，注意这次三角剖分和前面的方法都不一样，要确保符合如下定义

在数学和计算几何中，对于给定的平面中的离散点集 P，其 Delaunay 三角剖分 DT(P) 满足：
空圆性：DT(P) 是 唯一 的（任意四点不能共圆），在 DT(P) 中，任意 三角形的外接圆范围内不会有其它点存在。
最大化最小角：在点集 P 可能形成的三角剖分中，DT(P) 所形成的三角形的最小角最大。从这个意义上讲，DT(P) 是 最接近于规则化 的三角剖分。具体的说是在两个相邻的三角形构成凸四边形的对角线，在相互交换后，两个内角的最小角不再增大。
delaunay三角剖分的算法也有很多种，这里介绍一下源码中的处理流程。

1. 首先根据采样点数组构建外围一圈的边数组，保存起点和终点，起点标识和终点标识。起点标识为`_EV_HULL_`_终点标识为_`_EV_UNDEF_`
2. 然后遍历每个边，寻找合适的第三点，能够构成最小的内接圆。将构成该三角形的边加入数组，如果已经存在，更新左标识为faceID(当前三角形ID)

大致这个意思，可以自己画一下。然后可以发现每个三角形编号都出现了三次，直接遍历边数组根据三角形编号把对应顶点放入即可。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/21629258/1683727761734-88209f64-4cec-4552-a34c-6067aeebdaeb.png#averageHue=%23f9f8f7&clientId=u502f97a6-57e2-4&from=paste&height=680&id=ub87a3181&originHeight=680&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12745&status=done&style=none&taskId=udc1c2e85-f195-4d9b-885b-b51b4070ee6&title=&width=1008)
最后，将三角剖分的结构修正为世界坐标，加载到网格中，就得到了高度细节网格。
参考资料  
[简介](https://zhuanlan.zhihu.com/p/357242050)  
[细节](https://zhuanlan.zhihu.com/p/583887024)  
[更多](https://zhuanlan.zhihu.com/p/484520809)  
