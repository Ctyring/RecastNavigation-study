# RecastNavigation学习和注释
## SoloMesh方案
### 第一步 初始化配置
主要设置构建的区域，指定输入网格的边界等
### 第二步 光栅化输入的多边形
首先要标记可行走的三角形，计算方法是构造三角形的法线并归一化，然后和可行走的最大角度比较即可
可达的三角形被标记为`RC_WALKABLE_AREA`
然后正式进行光栅化。首先遍历所有三角形，对每个三角形单独处理。
对每个三角形进行切割，切割的具体思路是，看该图形的每条边的两个端点在切割轴的左边还是右边，如果异侧则产生切割，切割产生的新分离点是该边和分离轴的交点，根据比例即可得出。
首先在z轴上切割，切出长条，然后再在x轴上切割，得到小块的体素。然后计算在该小格在y轴上的范围。
最后需要把体素捕捉到高度场。高度场的结构是二维数组(x轴z轴)，每个节点是一个链表(y轴)在y轴中会按从低到高顺序保存体素。如果新插入的体素和之前的体素有重合，则会合并，所以最终会得到在y轴上连续合并后的体素结构。
至此完成初步体素化
### 第三步 过滤可行走表面
主要是根据高度场对可行走面进行修正一共三种情况，不可走的标记为`RC_NULL_AREA`

1. 过滤悬空的可行障碍物

这种情况通俗来说就是，如果一个障碍物悬空，但可以爬上去，则该障碍物也是可走的

2. 过滤高度差过大的障碍物

这种情况可以理解为，如果过于陡峭，则不能通过。
这里的高度都是指上表面高度
首先要判断可达邻居，条件为与当前体素的高度差能通过一个人。
高度差过大的判断条件：可达邻居的最大高度和最低高度差大于攀爬高度或该体素与可达邻居的最低高度差大于攀爬高度，都认为过于陡峭，不可达。

3. 过滤不可通过高度的障碍物

即两个y轴上的体素之间的空隙不能过一个人，则下面的体素设置为不可行走。
至此完成体素化部分的优化，下面开始进入反体素化
### 第四步 区域划分
首先要构建紧缩高度场，紧缩高度场保存的是体素之间的可行部分，即空隙部分。构建紧缩高度场的环节就是反体素化。
紧缩高度场的数据结构和高度场也有不同，紧缩高度场的y轴也是通过连续内存即数组的形式保存，所以需要保存反体素的总数。
构建紧缩高度场后还需要构建反体素之间的联通关系，联通的条件有两个：最小间距大于人，下表面高度差小于攀爬高度。
然后需要根据角色半径对可行表面进行裁剪：即边缘部分虽然理论可走，但角色有半径，不可能走到最边缘。步骤如下

- 首先将边界标记出来：边界的条件是：本身不可走或者四个方向存在不联通的方向。
- 计算每个反体素与边界的最近距离。遍历即可，需要正反遍历两遍来处理周围八个点(因为先后顺序问题)
- 如果与边界距离小于角色直径，视为不可走，标记为`RC_NULL_AREA`

裁剪后有一个可选环节，根据部署的多边形，对反体素的area进行标记(即游戏中的草地，沙漠等等)
然后正式开始区域划分，主要介绍分水岭算法

1. 该算法的第一步是构建距离场，所谓距离场和上文根据角色半径裁剪用的距离计算数组基本一致，区别是边界的条件不同，这里的边界不仅包含四个方向存在不联通或本身不可走，如果四个方向存在area不同(比如草地和沙漠)也视为边界。这里会保留最大距离，后面区域划分会用到。
2. 平滑处理，将得到的距离场和周围八个点取平均值(如果有不联通，用自己进行占位)
3. 一开始给边界(整个包围盒)的regionID加上`RC_BORDER_REG`，然后根据上述平滑处理后的距离场开始进行区域划分。首先，区域划分是分批次的，每次8个等级，循环进行。每个等级保存2格距离。根据最大距离向下逐个等级进行划分。具体的区域划分有两个环节，一个环节是水位蔓延，根据当前等级进行蔓延，如果同等级没有被蔓延，会在第二阶段：发现新水源阶段成为新的水源。每个新的水源代表一个新的区域。需要注意region的边界id为0
4. 划分好之后需要对regions进行合并和过滤。首先遍历所有反体素，统计每个regionID中的反体素数量，并在每个反体素的竖直方向上regionID比较，如果相同，说明对应的regionID存在重叠情况，标记。并且会把该数值方向上的全部region去重添加到各个region的floors中。然后判断一个反体素是否是边缘，判断条件:与邻居span不联通或者不是同一个regionID。如果是边缘，则进行一次边缘行走，得到所有的邻居(可以联通的)region。边缘行走的基本规则：**碰壁则向顺时针尝试，成功则前进一步并逆时针尝试**，这样最终能得到顺时针顺序的轮廓点排序。基于刚刚计算的反体素数量统计，如果有region的反体素数量过少，则遍历该region的邻居，使用宽搜进行统计，看如果全部合并是否能保证反体素数量是合适的。如果不满足条件，这次宽搜到的所有region都可以直接杀掉。然后进行region的合并。将过小的region合并到邻居region。合并邻居的选择条件：不能有多个联通(这样中间会包夹别的region)，不能处于上下floor，在此基础上，选择最小的邻居进行合并。合并后，重新编号以压缩区域数组。
### 轮廓化
到上一步为止，我们已经拿到了反体素并完成了区域划分，即每个反体素属于哪个区域。接下来我们将立体的反体素简化为轮廓。
首先，标记每个反体素四个方向是否为边界(regionID为0或者`RC_BORDER_REG`)
然后筛选出有部分方向为边界的反体素，进行轮廓点描绘，基本思路是绕着边界走一圈，将边界加入points数组。基本方法和上面的边缘行走差不多，有一个关键点是边缘的选取，要保证相邻的两个region共用一个边缘，所以要有一套规则：
```cpp
// 选取轮廓(为了保证周围的区域选出来的轮廓重合)
switch(dir)
{
    // 向左：取上
    case 0: pz++; break;
    // 向上：取右上
    case 1: px++; pz++; break;
    // 向右：取右
    case 2: px++; break;
    // 向下：取自身
}
```
在轮廓点中还会保存接壤点的情况，用于下面的简化轮廓线。
画出轮廓线之后，目前的轮廓点过于密集，其实只需要取其中一些关键点，构成多边形即可，这样即能优化性能，还可以减少锯齿。
首先对比本点和下一个轮廓点，如果两个轮廓点的接壤点不同，则把本点加入简化序列，如果没有这样的点，取左下和右上。然后：

1. 找出距离简化点围成的线段最远的点，如果不符合规定，就把该点加入。
2. 找出最长的线段，不符合规定，把中点加入

重复直到合格。
这时候已经得到了轮廓线，但内部会有回字形结构，需要去除这些回字形的空洞。
之前我们采用顺时针的方式进行边界遍历，那么内部的回字形就会是逆时针的(因为其实是从外部跑出来的)所以对面积进行叉乘，根据正负就能判断是外轮廓还是里面的空洞。
然后就要进行空洞合并或者说打通，即连接外轮廓和内轮廓，这样就可以保持只有一个轮廓。
合并的第一步是选点，找到内轮廓最左的点，并确保在外轮廓三个顶点围成的锥形区域内。然后用外轮廓的顶点对内轮廓的选定点进行连线，如果不和外轮廓即其他空洞相交，视为合法对角线，找到最短的合法对角线，如果没有合法对角线，内轮廓选择下一个最佳点。  
参考资料  
[https://zhuanlan.zhihu.com/p/357242050](https://zhuanlan.zhihu.com/p/357242050)  
[https://zhuanlan.zhihu.com/p/583887024](https://zhuanlan.zhihu.com/p/583887024)  
[https://zhuanlan.zhihu.com/p/484520809](https://zhuanlan.zhihu.com/p/484520809)  
